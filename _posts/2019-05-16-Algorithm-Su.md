---
title: "Algorithm"
date: 2019-05-16
comment: false

---

### 알고리즘의 기본

----

#### 알고리즘이란?

- 알고리즘은, 계산이나 작업을 하기 위한 순서를 의미합니다.

- 알고리즘은, 계산이나 작업을 하기 위한 순서를 의미합니다.



#### 알고리즘과 프로그램의 차이

- 알고리즘과 프로그램은 비슷하다고 생각될수 있으나 프로그램은 컴퓨터 상에서 실행할 수 있도록 컴퓨터가 이해 할 수 있는 언어로 작성하는 것에 반해, 알고리즘은 프로그램을 작성하는 이전 단계에서 사람이 이해할 수 있도록 작성하는 것입니다.
- 단, 어디까지가 알고리즘이고 어디까지가 프로그램인지 명확하게 구분짓는 것은 어렵습니다.
- 같은 알고리즘이라도, 사용한 언어가 다르면 다른 프로그램이 되고, 같은 언어를 사용한다고 해도 프로그램을 작성하는 사람에 따라 다른 프로그램이 됩니다.



-----



#### 정수를 순서대로 나열하는 알고리즘 : 정렬 (sort)

##### 	작은 숫자를 찾아서 교환하기 : 선택 정렬

- 아무렇게나 나열되어있는 정수를 입력받아서 작은 것부터 차례로 재나열하는 것입니다.

- 알고리즘은 어떤 입력값에 대해서도 대응할 수 있는 일반적인 방법을 기술해야합니다.



![image](https://user-images.githubusercontent.com/26815767/57982966-421ed000-7a87-11e9-834b-93d7e464d7c1.png)

- 입력값 중 가장 작은 값을 찾아 가장 왼쪽의 숫자와 교환

- 1은 고정되어서 움직이지 않는다.

- 남은 숫자 중 가장 작은 수를 찾아서 두 번째와 교환

- 숫자 갯수만큼 이 작업을 반복한다.

  

![image](https://user-images.githubusercontent.com/26815767/57983057-75ae2a00-7a88-11e9-97d5-fe989d299048.png)

- 모두 정리됨

  

- 정렬 알고리즘에는 선택 정렬만이 있는 것이 아니다.
- 같은 문제를 푸는 알고리즘이 여러 개 있을 때 어떤것을 사용하면 좋은가?



#### 알고리즘 선택 방법

- 컴퓨터는 몇 개의 기본 명령을 가지고 있어서 이것을 빠르게 실행하지만 복잡한 명령을 실행하는것은 어렵다.

- 그래서 컴퓨터는 기본 명령을 조합하여 복잡한 명령을 수행한다.

1. 간단한 알고리즘 사용
   - 간단한 알고리즘은 사람이 이해하기 쉽고 프로그램으로 작성하기도 쉽다.
   - 또한 실행 중에 기억 영역이 적어도 되는 알고리즘은 메모리가 작은 컴퓨터 상에서도 동작한다.

2. 시간이 더 적게 드는 알고리즘
   - 일반적으로 중요시되는 것은 '시간'.
   -  = 주어진 입력 값으로 답을 내기까지 걸리는 ☆시간☆.



Ex) 완전 탐색

[n가지의 숫자가 나열 되어 있을 경우 왼쪽부터 읽으면서 가장 작은 순서대로 나열되어 있으면 그것을 출력, 
그렇지 않으면 1부터 수열을 만든다.]

- 완전 탐색 알고리즘에서는 나열된 모든 값을 확인하므로 어떤 입력 값이 주어지더라도 항상 맞는 답을 출력.
- 운이 좋으면 바로 답을 찾겠지만 최악의 경우에는 찾을 값이 마지막에 있을 수 있다.
- 그러므로 n개의 숫자가 나열되어 있다면 n!만큼의 경우까지 생각된다.



탐색할 수가 50인 경우

- 완전 탐색 : 50! = 50 * 49 * 48 * ... * 3 * 2 * 1

- 선택 정렬 : 50 + 49 + 48 + ... + 2 + 1

-> 선택 정렬의 경우가 훨씬 적다.



----



### 계산 시간 측정



#### 입력 크기와 계산 시간과의 관계 이해하기

- 알고리즘에 따라 크게 달라짐
- 10개의 숫자 정렬과 10000000개의 숫자 정렬은 다르다!
- 알고리즘간의 실행 시간뿐 아니라 같은 알고리즘 사이에서도 입력의 크기에 따라 알고리즘 계산 시간이 얼마나 달라지는가를 생각해야 한다.

#### 계산 시간 구하는 법

- 입력 변화에 따른 계산 시간 변화를 구한다.
- 프로그램을 작동시켜서 실제로 걸리는 시간을 측정하는 것이 가장 좋은 방법이지만 이 방법은 같은 알고리즘이라도 컴퓨터에 따라 계산 시간이 달라진다.
- 따라서, 계산 시간에는 '스탭 수'를 활용합니다.
- 1스탭은 계산의 기본 단위로, 계산을 종료하기까지 기본 단위를 몇 회 실행했느냐로 계산 시간을 측정합니다.



#### 선택 정렬에서의 계산시간 측정

1. 수열에서 최솟값을 찾는다.

2. 최솟값을 수열의 가장 왼쪽의 숫자와 교환하고 정렬을 끝낸다.

3. (1)로 돌아간다.

   

- 수열의 숫자 개수 : n

- '하나의 숫자를 확인한다'라는 조작을 기본 단위로 가정. 이 때 걸리는 시간 Tc

- 1은 n * Tc시간에 끝난다.

- '두 개의 숫자를 교환한다'라는 조작도 기본 단위로 Ts시간이 걸린다 가정

- n과 관계없이 교환을 한번만 하므로 Ts시간에 끝난다.

- n회 반복하고 1회의 라운드마다 확인할 숫자가 줄어드므로 n-1

  

  (n * Tc + Ts)+((n - 1) * Tc + Ts) + ((n - 2) * Tc + Ts) + … + (2 * Tc + Ts) + (1 * Tc + Ts)

  =1/2 * Tc * n(n + 1)+Ts * n

  =1/2 * Tc * n^2  + (1/2 * Tc + Ts) * n



#### 계산 시간을 표현하는 방법

- 간단하게 시간을 표현하는 방법

  -> 1/2 * Tc * n^2  + (1/2 * Tc + Ts) * n = O(n^2)

- O : (big O)

- O(n^2) : 계산 시간이 최악의 경우 n^2의 배수가 된다.

- 예를 들어, 선택 정렬의 계산 시간이 O(n^2)이며 퀵 정렬의 계산 시간이 O(n log n)이라는 정보가 주어진 경우 퀵 정렬의 시간이 빠르다는 것을 알 수 있다.

- 또한 입력의 크기 n의 변화에 따라 계산 시간이 어느 정도 달라지는지도 한눈에 파악할 수 있다.



